def not_to_not :  (l?34 : cts.Sort) -> (l?37 : cts.Sort) ->
  cts.Term
    (cts.max (cts.succ l?37) (cts.max (cts.succ l?34) (cts.max (cts.max l?37 l?34) (cts.max l?34 l?37))))
    (cts.prod
       (cts.succ l?37)
       (cts.max (cts.succ l?34) (cts.max (cts.max l?37 l?34) (cts.max l?34 l?37)))
       (cts.max (cts.succ l?37) (cts.max (cts.succ l?34) (cts.max (cts.max l?37 l?34) (cts.max l?34 l?37))))
       cts.I
       (cts.univ l?37 (cts.succ l?37) cts.I)
       (x =>
        cts.prod
          (cts.succ l?34)
          (cts.max (cts.max l?37 l?34) (cts.max l?34 l?37))
          (cts.max (cts.succ l?34) (cts.max (cts.max l?37 l?34) (cts.max l?34 l?37)))
          cts.I
          (cts.univ l?34 (cts.succ l?34) cts.I)
          (x0 =>
           cts.prod
             (cts.max l?37 l?34)
             (cts.max l?34 l?37)
             (cts.max (cts.max l?37 l?34) (cts.max l?34 l?37))
             cts.I
             (cts.prod
                l?37
                l?34
                (cts.max l?37 l?34)
                cts.I
                x
                (x1 => x0))
             (x1 =>
              cts.prod
                l?34
                l?37
                (cts.max l?34 l?37)
                cts.I
                (Not.Not l?34 x0)
                (x2 => Not.Not l?37 x)))))
  := l?34 => l?37 =>
  A:(cts.Term (cts.succ l?37) (cts.univ l?37 (cts.succ l?37) cts.I)) =>
  B:(cts.Term (cts.succ l?34) (cts.univ l?34 (cts.succ l?34) cts.I)) =>
  auto:(cts.Term
          (cts.max l?37 l?34)
          (cts.prod l?37 l?34 (cts.max l?37 l?34) cts.I A (x => B))) =>
  auto':(cts.Term l?34 (Not.Not l?34 B)) =>
  nmk.nmk
    cts.zero
    l?37
    A
    (auto'':(cts.Term l?37 A) =>
     absurd.absurd l?34 cts.zero B (auto auto'') auto').

