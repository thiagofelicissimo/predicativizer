def distributive_times_minus :
  cts.Term cts.star (distributive.distributive nat.nat times.times minus.minus)
  :=
  a:(cts.Term cts.box nat.nat) =>
  b:(cts.Term cts.box nat.nat) =>
  c:(cts.Term cts.box nat.nat) =>
  match_Or_prop.match_Or_prop
    (lt.lt b c)
    (Not.Not (lt.lt b c))
    (eq.eq
       nat.nat
       (times.times a (minus.minus b c))
       (minus.minus (times.times a b) (times.times a c)))
    (Hbc:(cts.Term cts.star (lt.lt b c)) =>
     eq_ind_r.eq_ind_r
       nat.nat
       O.O
       (x:(cts.Term cts.box nat.nat) =>
        eq.eq nat.nat (times.times a x) (minus.minus (times.times a b) (times.times a c)))
       (eq_ind_r.eq_ind_r
          nat.nat
          O.O
          (x:(cts.Term cts.box nat.nat) => eq.eq nat.nat (times.times a O.O) x)
          (rewrite_l.rewrite_l
             nat.nat
             O.O
             (__:(cts.Term cts.box nat.nat) => eq.eq nat.nat __ O.O)
             (refl.refl nat.nat O.O)
             (times.times a O.O)
             (times_n_O.times_n_O a))
          (minus.minus (times.times a b) (times.times a c))
          (eq_minus_O.eq_minus_O
             (times.times a b)
             (times.times a c)
             (monotonic_le_times_r.monotonic_le_times_r a b c (lt_to_le.lt_to_le b c Hbc))))
       (minus.minus b c)
       (eq_minus_O.eq_minus_O b c (lt_to_le.lt_to_le b c Hbc)))
    (Hbc:(cts.Term cts.star (Not.Not (lt.lt b c))) =>
     sym_eq.sym_eq
       nat.nat
       (minus.minus (times.times a b) (times.times a c))
       (times.times a (minus.minus b c))
       (eq_coerc.eq_coerc
          (eq.eq
             nat.nat
             (minus.minus (times.times a b) (times.times a c))
             (times.times a (minus.minus b c)))
          (eq.eq
             nat.nat
             (minus.minus (times.times a b) (times.times a c))
             (times.times a (minus.minus b c)))
          (plus_to_minus.plus_to_minus
             (times.times a b)
             (times.times a c)
             (times.times a (minus.minus b c))
             (eq_ind.eq_ind
                nat.nat
                (times.times a (plus.plus c (minus.minus b c)))
                (x_1:(cts.Term cts.box nat.nat) => eq.eq nat.nat (times.times a b) x_1)
                (eq_f.eq_f
                   nat.nat
                   nat.nat
                   (times.times a)
                   b
                   (plus.plus c (minus.minus b c))
                   (eq_coerc.eq_coerc
                      (eq.eq nat.nat b (plus.plus (minus.minus b c) c))
                      (eq.eq nat.nat b (plus.plus c (minus.minus b c)))
                      (plus_minus_m_m.plus_minus_m_m b c (not_lt_to_le.not_lt_to_le b c Hbc))
                      (rewrite_r.rewrite_r
                         nat.nat
                         (plus.plus c (minus.minus b c))
                         (__:(cts.Term cts.box nat.nat) =>
                          eq.eq
                            (cts.univ cts.star cts.box cts.I)
                            (eq.eq nat.nat b __)
                            (eq.eq nat.nat b (plus.plus c (minus.minus b c))))
                         (refl.refl
                            (cts.univ cts.star cts.box cts.I)
                            (eq.eq nat.nat b (plus.plus c (minus.minus b c))))
                         (plus.plus (minus.minus b c) c)
                         (commutative_plus.commutative_plus (minus.minus b c) c))))
                (plus.plus (times.times a c) (times.times a (minus.minus b c)))
                (distributive_times_plus.distributive_times_plus a c (minus.minus b c))))
          (refl.refl
             (cts.univ cts.star cts.box cts.I)
             (eq.eq
                nat.nat
                (minus.minus (times.times a b) (times.times a c))
                (times.times a (minus.minus b c))))))
    (decidable_lt.decidable_lt b c).

