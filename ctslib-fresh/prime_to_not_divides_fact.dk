def prime_to_not_divides_fact :
  cts.Term
    cts.star
    (cts.prod
       cts.box
       cts.star
       cts.star
       cts.I
       nat.nat
       (x =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (prime.prime x)
          (x0 =>
           cts.prod
             cts.box
             cts.star
             cts.star
             cts.I
             nat.nat
             (x1 =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (lt.lt x1 x)
                (x2 => Not.Not (divides.divides x (fact.fact x1)))))))
  :=
  p:(cts.Term cts.box nat.nat) =>
  primep:(cts.Term cts.star (prime.prime p)) =>
  n:(cts.Term cts.box nat.nat) =>
  nat_ind.nat_ind
    (_x_365:(cts.Term cts.box nat.nat) =>
     cts.prod
       cts.star
       cts.star
       cts.star
       cts.I
       (lt.lt _x_365 p)
       (x => Not.Not (divides.divides p (fact.fact _x_365))))
    (sym_eq_fact.sym_eq_fact
       O.O
       (y:(cts.Term cts.box nat.nat) =>
        cts.prod cts.star cts.star cts.star cts.I (lt.lt O.O p) (x => Not.Not (divides.divides p y)))
       (sym_eq_filter_nat_type_O.sym_eq_filter_nat_type_O
          nat.nat
          fact_body.fact_body
          (y:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (lt.lt O.O p)
             (x => Not.Not (divides.divides p y)))
          (sym_eq_fact_body_O.sym_eq_fact_body_O
             (y:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (lt.lt O.O p)
                (x => Not.Not (divides.divides p y)))
             (__:(cts.Term cts.star (le.le (S.S O.O) p)) =>
              nmk.nmk
                (divides.divides p (S.S O.O))
                (divp:(cts.Term cts.star (divides.divides p (S.S O.O))) =>
                 absurd.absurd
                   (le.le p (S.S O.O))
                   (divides_to_le.divides_to_le p (S.S O.O) (lt_O_S.lt_O_S O.O) divp)
                   (lt_to_not_le.lt_to_not_le
                      (S.S O.O)
                      p
                      (prime_to_lt_SO.prime_to_lt_SO p primep)))))))
    (n1:(cts.Term cts.box nat.nat) =>
     sym_eq_fact.sym_eq_fact
       (S.S n1)
       (y:(cts.Term cts.box nat.nat) =>
        cts.prod
          cts.star
          cts.star
          cts.star
          cts.I
          (cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (lt.lt n1 p)
             (x => Not.Not (divides.divides p (fact.fact n1))))
          (x =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (lt.lt (S.S n1) p)
             (x0 => Not.Not (divides.divides p y))))
       (sym_eq_filter_nat_type_S.sym_eq_filter_nat_type_S
          nat.nat
          fact_body.fact_body
          n1
          (y:(cts.Term cts.box nat.nat) =>
           cts.prod
             cts.star
             cts.star
             cts.star
             cts.I
             (cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (lt.lt n1 p)
                (x => Not.Not (divides.divides p (fact.fact n1))))
             (x =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (lt.lt (S.S n1) p)
                (x0 => Not.Not (divides.divides p y))))
          (sym_eq_fact_body_S.sym_eq_fact_body_S
             n1
             (y:(cts.Term cts.box nat.nat) =>
              cts.prod
                cts.star
                cts.star
                cts.star
                cts.I
                (cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (lt.lt n1 p)
                   (x => Not.Not (divides.divides p (fact.fact n1))))
                (x =>
                 cts.prod
                   cts.star
                   cts.star
                   cts.star
                   cts.I
                   (lt.lt (S.S n1) p)
                   (x0 => Not.Not (divides.divides p y))))
             (Hind:(cts.Term
                      cts.star
                      (cts.prod
                         cts.star
                         cts.star
                         cts.star
                         cts.I
                         (lt.lt n1 p)
                         (x => Not.Not (divides.divides p (fact.fact n1))))) =>
              ltn1:(cts.Term cts.star (lt.lt (S.S n1) p)) =>
              nmk.nmk
                (divides.divides p (times.times (fact.fact n1) (S.S n1)))
                (Hdiv:(cts.Term
                         cts.star
                         (divides.divides p (times.times (fact.fact n1) (S.S n1)))) =>
                 match_Or_prop.match_Or_prop
                   (divides.divides p (fact.fact n1))
                   (divides.divides p (S.S n1))
                   False.False
                   (Hdiv0:(cts.Term cts.star (divides.divides p (fact.fact n1))) =>
                    absurd.absurd
                      (divides.divides p (fact.fact n1))
                      Hdiv0
                      (Hind (lt_to_le.lt_to_le (S.S n1) p ltn1)))
                   (Hdiv0:(cts.Term cts.star (divides.divides p (S.S n1))) =>
                    absurd.absurd
                      (le.le p (S.S n1))
                      (divides_to_le.divides_to_le p (S.S n1) (lt_O_S.lt_O_S n1) Hdiv0)
                      (lt_to_not_le.lt_to_not_le (S.S n1) p ltn1))
                   (divides_times_to_divides.divides_times_to_divides
                      p
                      (fact.fact n1)
                      (S.S n1)
                      primep
                      Hdiv))))))
    n.

